% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class_worker.R
\name{class_worker}
\alias{class_worker}
\alias{worker}
\title{Worker class.}
\description{
\code{R6} class for a worker.
}
\details{
A worker object is an interface to manage a single
high-performance computing worker. Supported methods
send jobs, receive output, and poll, etc.
This particular worker class is the parent abstract class
and is not usable on its own. Subclasses like
\link{class_worker_callr} and \link{class_worker_future}
are concrete and usable. In addition, worker needs a crew in
order to be valid. So it is recommended to create a worker
of a given subclass through the \code{recruit()} method of the crew.
See the examples.
}
\examples{
crew <- class_crew$new(worker_classes = list(class_worker_callr))
crew$recruit(workers = 1)
worker <- crew$workers[[1]]
worker$send(fun = function(arg) paste("job", arg), args = list(arg = 1))
while (!worker$receivable()) Sys.sleep(0.1)
job <- worker$receive()
print(job$value)
print(job$error)
worker$shutdown()
processx::supervisor_kill()
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{name}}{Character of length 1, worker name.}

\item{\code{crew}}{\code{R6} crew object to which the worker belongs.}

\item{\code{timeout}}{Positive numeric of length 1,
number of seconds of idling for the worker to time out.}

\item{\code{wait}}{Positive numeric of length 1,
number of seconds in a polling interval, e.g. checking
if an input job exists.}

\item{\code{tags}}{Character vector of optional user-defined tags
to select subsets of eligible workers for job submission and
retrieval.}

\item{\code{assigned}}{Logical of length 1, whether the worker
already has a job to do.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{class_worker$new()}}
\item \href{#method-tagged}{\code{class_worker$tagged()}}
\item \href{#method-sendable}{\code{class_worker$sendable()}}
\item \href{#method-send}{\code{class_worker$send()}}
\item \href{#method-receivable}{\code{class_worker$receivable()}}
\item \href{#method-receive}{\code{class_worker$receive()}}
\item \href{#method-clear}{\code{class_worker$clear()}}
\item \href{#method-shutdown}{\code{class_worker$shutdown()}}
\item \href{#method-stuck}{\code{class_worker$stuck()}}
\item \href{#method-restart}{\code{class_worker$restart()}}
\item \href{#method-validate}{\code{class_worker$validate()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Worker constructor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$new(
  name = basename(tempfile(pattern = "worker_")),
  crew = NULL,
  timeout = 60,
  wait = 0.1,
  tags = character(0)
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{Character of length 1, worker name.}

\item{\code{crew}}{\code{R6} crew object to which the worker belongs.}

\item{\code{timeout}}{Positive numeric of length 1, number of seconds
that a worker can idle before timing out.}

\item{\code{wait}}{Positive numeric of length 1, number of seconds
in a polling interval, e.g. checking if an input job exists.}

\item{\code{tags}}{Character vector of optional user-defined tags
to mark eligible groups of workers in scheduling operations.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The \code{new()} method calls the constructor
and returns a new worker object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-tagged"></a>}}
\if{latex}{\out{\hypertarget{method-tagged}{}}}
\subsection{Method \code{tagged()}}{
Check if the worker has one or more
of the tags in the argument.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$tagged(tags)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tags}}{Character vector of tags to check.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{TRUE} if the worker has any of the tags in the \code{tags} argument.
\code{FALSE} otherwise.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sendable"></a>}}
\if{latex}{\out{\hypertarget{method-sendable}{}}}
\subsection{Method \code{sendable()}}{
Check if this worker is ready to accept a job.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$sendable()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{TRUE} if the worker is ready for a job
(or not properly blocked) and \code{FALSE} otherwise.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-send"></a>}}
\if{latex}{\out{\hypertarget{method-send}{}}}
\subsection{Method \code{send()}}{
Send a job.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$send(fun = function() TRUE, args = list(), timeout = 60, wait = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fun}}{Function to run in the job. Should be completely
self-contained in the body and arguments, without relying
on the closure or global variables in the environment.}

\item{\code{args}}{Named list of arguments to \code{fun}.}

\item{\code{timeout}}{Number of seconds to wait for job data to
send successfully.}

\item{\code{wait}}{Number of seconds to wait between iterations checking
if the job data was sent successfully.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{NULL} (invisibly).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-receivable"></a>}}
\if{latex}{\out{\hypertarget{method-receivable}{}}}
\subsection{Method \code{receivable()}}{
Check if job output is available to collect.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$receivable()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{TRUE} if a job output can be collected from the worker,
\code{FALSE} otherwise.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-receive"></a>}}
\if{latex}{\out{\hypertarget{method-receive}{}}}
\subsection{Method \code{receive()}}{
Collect the results of a job and free up the worker.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$receive(timeout = 60, wait = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{timeout}}{Number of seconds to wait for the file deletion to
succeed.}

\item{\code{wait}}{Number of seconds to wait between iterations checking
that the worker files were successfully removed from the data store.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Once collected and returned. the job output is deleted from
the data store and no longer available to receive.
\code{receive()} also marks the worker as "sendable" again (unblocked)
which makes the worker ready for another job (\code{send()} method).
}

\subsection{Returns}{
A named list of job output. The \code{value} element has the
actual result of the job function, if successful. Other elements
have job metadata such as the error message (if any), traceback,
warnings, and runtime in seconds.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clear"></a>}}
\if{latex}{\out{\hypertarget{method-clear}{}}}
\subsection{Method \code{clear()}}{
Clear worker input and output.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$clear(timeout = 60, wait = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{timeout}}{Number of seconds to wait for the file deletion to
succeed.}

\item{\code{wait}}{Number of seconds to wait between iterations checking
that the worker files were successfully removed from the data store.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Deletes worker input and output files.
}

\subsection{Returns}{
\code{NULL} (invisibly)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-shutdown"></a>}}
\if{latex}{\out{\hypertarget{method-shutdown}{}}}
\subsection{Method \code{shutdown()}}{
Gracefully shut down the worker.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$shutdown()}\if{html}{\out{</div>}}
}

\subsection{Details}{
The underlying worker process should promptly
shut down if successful. A new \code{send()} or \code{launch()}
call will re-launch the worker.

The default shutdown method
sends a special shutdown job through the data store.
This is not always reliable, e.g. if a worker freezes.
Subclasses of \code{class_worker} should write their own
shutdown methods that leverage the backend technology.
to achieve more reliable shutdowns.
}

\subsection{Returns}{
\code{NULL} (invisibly).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-stuck"></a>}}
\if{latex}{\out{\hypertarget{method-stuck}{}}}
\subsection{Method \code{stuck()}}{
Check if a worker is stuck.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$stuck()}\if{html}{\out{</div>}}
}

\subsection{Details}{
A worker is stuck if it is down, not sendable,
and not receivable.
}

\subsection{Returns}{
Logical of length 1, whether the worker is stuck.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-restart"></a>}}
\if{latex}{\out{\hypertarget{method-restart}{}}}
\subsection{Method \code{restart()}}{
Relaunch the worker if it is stuck.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$restart()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{NULL} (invisibly).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-validate"></a>}}
\if{latex}{\out{\hypertarget{method-validate}{}}}
\subsection{Method \code{validate()}}{
Worker validator.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{class_worker$validate()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{NULL} (invisibly).
}
}
}
