% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crew_queue.R
\name{crew_queue}
\alias{crew_queue}
\title{Abstract queue}
\description{
Abstract class for a task queue.
}
\details{
This is an abstract class and not runnable by itself.
Please instantiate using a subclass such as \link{crew_queue_session}.
}
\section{Queue attribution}{

The design and implementation of \code{crew} task queues, especially
the local \code{callr}-based task queues, borrows heavily from
the work of Gábor Csárdi, particularly
\url{https://www.tidyverse.org/blog/2019/09/callr-task-q/},
which was also released in commit
\verb{811a02f604de2cf03264f6b35ce9ec8a412f2581}
of \url{https://github.com/r-lib/callr} in the
\code{vignettes/Task-queue-with-callr.Rmd}
file under the MIT license. See the \code{crew} package \code{README.md} and
\code{NOTICE} files for other mentions of this attribution.
}

\examples{
fun <- function(x) x + 1
args <- list(x = 1)
queue <- crew_queue_session$new(timeout = 60, wait = 0.1)
queue$push(fun = fun, args = args)
queue$block()
result <- queue$pop()
str(result)
result$result$result
queue$shutdown()
processx::supervisor_kill()
}
\seealso{
Other queue: 
\code{\link{crew_queue_bg}},
\code{\link{crew_queue_future}},
\code{\link{crew_queue_session}}
}
\concept{queue}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{crew_queue$new()}}
\item \href{#method-get_tasks}{\code{crew_queue$get_tasks()}}
\item \href{#method-get_results}{\code{crew_queue$get_results()}}
\item \href{#method-get_workers}{\code{crew_queue$get_workers()}}
\item \href{#method-push}{\code{crew_queue$push()}}
\item \href{#method-pop}{\code{crew_queue$pop()}}
\item \href{#method-update}{\code{crew_queue$update()}}
\item \href{#method-crashed}{\code{crew_queue$crashed()}}
\item \href{#method-block}{\code{crew_queue$block()}}
\item \href{#method-shutdown}{\code{crew_queue$shutdown()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Abstract queue constructor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$new(
  workers = 1,
  store = crew_store_local$new(timeout = timeout, wait = wait),
  timeout = 60,
  wait = 0.1,
  max_tasks = Inf
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{workers}}{Number of workers in the queue.}

\item{\code{store}}{Data store object created with \link{crew_store_local}
or similar.}

\item{\code{timeout}}{Number of seconds to for a worker to wait
for something to happen (e.g. the arrival of a task)
before timing out and quitting.}

\item{\code{wait}}{Number of seconds to wait in between iterations while
waiting for something to happen (e.g. the arrival of a task).}

\item{\code{max_tasks}}{Number of tasks a worker can run before quitting.
Some queues allow the worker to restart when launching a new task.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An abstract queue object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-get_tasks}{}}}
\subsection{Method \code{get_tasks()}}{
Show the queued tasks pushed with the \code{push()} method
but not yet assigned to workers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$get_tasks()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A data frame with one row per queued task
and columns describing each task.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_results"></a>}}
\if{latex}{\out{\hypertarget{method-get_results}{}}}
\subsection{Method \code{get_results()}}{
Show the results completed by the workers and available
to retrieve with the \code{pop()} method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$get_results()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A data frame with one row per completed task
and columns describing each task.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_workers"></a>}}
\if{latex}{\out{\hypertarget{method-get_workers}{}}}
\subsection{Method \code{get_workers()}}{
Show the workers of the queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$get_workers()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A data frame with one row per worker
and columns describing each worker.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-push"></a>}}
\if{latex}{\out{\hypertarget{method-push}{}}}
\subsection{Method \code{push()}}{
Push a new task on to the queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$push(fun, args = list(), task = crew_name(), update = TRUE, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fun}}{R function that runs the task.}

\item{\code{args}}{Named list of arguments to \code{fun}.}

\item{\code{task}}{Character of length 1 with the task ID.}

\item{\code{update}}{Logical of length 1, whether to update the
internal state of the queue after pushing. See the
\code{update()} method for details.}

\item{\code{...}}{Named arguments specific to each job, such as the
\code{future} plan for \link{crew_queue_future} queues.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{NULL} (invisibly)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pop"></a>}}
\if{latex}{\out{\hypertarget{method-pop}{}}}
\subsection{Method \code{pop()}}{
Pop the results of a completed task off the queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$pop(update = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{update}}{Logical of length 1, whether to update the
internal state of the queue after pushing. See the
\code{update()} method for details.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A named list with the results of the task.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update"></a>}}
\if{latex}{\out{\hypertarget{method-update}{}}}
\subsection{Method \code{update()}}{
Update the internal state of the queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$update()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Updating moves tasks along and make sure they get
assigned to workers and cleaned up in a timely manner.
However, there may be a computational overhead cost
if updates happen too often. It is recommended to have
an event loop that updates the queue, (preferably via
methods \code{push()} and \code{pop()} instead of \code{update()} directly)
that updates the queue at a time interval that appropriately
balances the tradeoffs.
}

\subsection{Returns}{
\code{NULL} (invisibly)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-crashed"></a>}}
\if{latex}{\out{\hypertarget{method-crashed}{}}}
\subsection{Method \code{crashed()}}{
Detect crashed workers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$crashed()}\if{html}{\out{</div>}}
}

\subsection{Details}{
This usually happens during \code{update()} anyway.
}

\subsection{Returns}{
Return \code{NULL} (invisibly) if no workers crashed.
Throw an error if at least one worker crashed.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-block"></a>}}
\if{latex}{\out{\hypertarget{method-block}{}}}
\subsection{Method \code{block()}}{
Block the R session until there are no unassigned
tasks and at least one worker is available.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$block(timeout = NULL, wait = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{timeout}}{Number of seconds to wait to clear the queue backlog.
Defaults to the \code{timeout} value assigned at initialization.}

\item{\code{wait}}{Number of seconds to wait in between update iterations.
Defaults to the \code{wait} value assigned at initialization.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The \code{block()} method calls \code{update()} every \code{wait} seconds
until the backlog is clear or \code{timeout} is reached. It is a
convenient event loop if you want to clear the backlog before
taking any other action, but most event loops continuously
assign tasks with \code{push()} and retrieve available ones with \code{pop()}.
}

\subsection{Returns}{
\code{NULL} (invisibly)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-shutdown"></a>}}
\if{latex}{\out{\hypertarget{method-shutdown}{}}}
\subsection{Method \code{shutdown()}}{
Shut down the workers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue$shutdown()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Not all queues can shut down all their workers.
For example, \code{shutdown()} in \link{crew_queue_future} can shut down its
\code{callr}-based subqueue, but it cannot shut down its \code{future}
workers. Local subqueues such as \link{crew_queue_session}
and \link{crew_queue_bg} can shut down completely.
}

\subsection{Returns}{
\code{NULL} (invisibly)
}
}
}
