% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crew_queue_future.R
\name{crew_queue_future}
\alias{crew_queue_future}
\title{Future queue}
\description{
Task queue with \code{future} workers.
}
\details{
Some public methods are inherited from \link{crew_queue}.
See the \link{crew_queue} help file for details on those.

The workers in this queue are futures with the \code{future} package.
In \code{push()}, it is possible to supply different \code{future::plan()}s
to different futures, and the queue itself has its own default plan.
Plans must be serializable, so only the \code{sequential}
and \code{future.batchtools} plans are supported.
The queue has a subqueue from \link{crew_queue_session} (or \link{crew_queue_bg}
if absolutely necessary) to submit and poll futures in order to
eliminate the otherwise heavy overhead of \code{future::future()} and
\code{future::resolved()} in \code{future.batchtools} futures. Tasks are
sent and collected using a \link{crew_store_local} data store
in order to eliminate the normally heavy overhead of \code{future::value()}.
}
\section{Queue attribution}{

The design and implementation of \code{crew} task queues, especially
the local \code{callr}-based task queues, borrows heavily from
the work of Gábor Csárdi, particularly
\url{https://www.tidyverse.org/blog/2019/09/callr-task-q/},
which was also released in commit
\verb{811a02f604de2cf03264f6b35ce9ec8a412f2581}
of \url{https://github.com/r-lib/callr} in the
\code{vignettes/Task-queue-with-callr.Rmd}
file under the MIT license. See the \code{crew} package \code{README.md} and
\code{NOTICE} files for other mentions of this attribution.
}

\examples{
fun <- function(x) x + 1
args <- list(x = 1)
queue <- crew_queue_future$new(timeout = 60, wait = 0.1)
queue$push(fun = fun, args = args)
queue$block()
result <- queue$pop()
str(result)
result$result$result
queue$shutdown()
processx::supervisor_kill()
}
\seealso{
Other queue: 
\code{\link{crew_queue_bg}},
\code{\link{crew_queue_session}},
\code{\link{crew_queue}}
}
\concept{queue}
\section{Super class}{
\code{\link[crew:crew_queue]{crew::crew_queue}} -> \code{crew_queue_future}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-crew_queue_future-new}{\code{crew_queue_future$new()}}
\item \href{#method-crew_queue_future-get_plan}{\code{crew_queue_future$get_plan()}}
\item \href{#method-crew_queue_future-push}{\code{crew_queue_future$push()}}
}
}
\if{html}{\out{
<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_queue" data-id="block"><a href='../../crew/html/crew_queue.html#method-crew_queue-block'><code>crew::crew_queue$block()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_queue" data-id="crashed"><a href='../../crew/html/crew_queue.html#method-crew_queue-crashed'><code>crew::crew_queue$crashed()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_queue" data-id="get_results"><a href='../../crew/html/crew_queue.html#method-crew_queue-get_results'><code>crew::crew_queue$get_results()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_queue" data-id="get_tasks"><a href='../../crew/html/crew_queue.html#method-crew_queue-get_tasks'><code>crew::crew_queue$get_tasks()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_queue" data-id="get_workers"><a href='../../crew/html/crew_queue.html#method-crew_queue-get_workers'><code>crew::crew_queue$get_workers()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_queue" data-id="pop"><a href='../../crew/html/crew_queue.html#method-crew_queue-pop'><code>crew::crew_queue$pop()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_queue" data-id="shutdown"><a href='../../crew/html/crew_queue.html#method-crew_queue-shutdown'><code>crew::crew_queue$shutdown()</code></a></span></li>
<li><span class="pkg-link" data-pkg="crew" data-topic="crew_queue" data-id="update"><a href='../../crew/html/crew_queue.html#method-crew_queue-update'><code>crew::crew_queue$update()</code></a></span></li>
</ul>
</details>
}}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-crew_queue_future-new"></a>}}
\if{latex}{\out{\hypertarget{method-crew_queue_future-new}{}}}
\subsection{Method \code{new()}}{
Abstract queue constructor.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue_future$new(
  workers = 1,
  store = crew_store_local$new(timeout = timeout, wait = wait),
  timeout = 60,
  wait = 0.1,
  max_tasks = Inf,
  plan = future::plan(),
  subqueue = crew_queue_session$new(workers = 1, wait = wait, timeout = timeout)
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{workers}}{Number of workers in the queue.}

\item{\code{store}}{Data store object created with \link{crew_store_local}
or similar.}

\item{\code{timeout}}{Number of seconds to for a worker to wait
for something to happen (e.g. the arrival of a task)
before timing out and quitting.}

\item{\code{wait}}{Number of seconds to wait in between iterations while
waiting for something to happen (e.g. the arrival of a task).}

\item{\code{max_tasks}}{Number of tasks a worker can run before quitting.
Some queues allow the worker to restart when launching a new task.}

\item{\code{plan}}{A \code{future::plan()} object with the default plan.}

\item{\code{subqueue}}{An object from \link{crew_queue_session} (or
\link{crew_queue_bg} if absolutely necessary) with the subqueue
which submits and collects futures in order to reduce overhead.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An abstract queue object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-crew_queue_future-get_plan"></a>}}
\if{latex}{\out{\hypertarget{method-crew_queue_future-get_plan}{}}}
\subsection{Method \code{get_plan()}}{
Get the default \code{future} plan of the queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue_future$get_plan()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The default \code{future} plan object of the queue.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-crew_queue_future-push"></a>}}
\if{latex}{\out{\hypertarget{method-crew_queue_future-push}{}}}
\subsection{Method \code{push()}}{
Push a new task on to the queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{crew_queue_future$push(
  fun,
  args = list(),
  task = crew_name(),
  update = TRUE,
  plan = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fun}}{R function that runs the task.}

\item{\code{args}}{Named list of arguments to \code{fun}.}

\item{\code{task}}{Character of length 1 with the task ID. This ID
gets passed to the \code{label} object of \code{future::future()}
which shows up on \code{htop} and cluster viewing commands
such as \code{squeue} for SLURM and \code{qstat} for SGE.}

\item{\code{update}}{Logical of length 1, whether to update the
internal state of the queue after pushing. See the
\code{update()} method for details.}

\item{\code{plan}}{An optional \code{future} plan object for the task.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{NULL} (invisibly)
}
}
}
