---
title: "Specification"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Specification}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(crew)
```

This vignette is a specification of the classes in `crew`. Sub-classes are listed, but only the ones implemented in the `crew` package itself. Other sub-classes may be developed in packages that depend on `crew`.

# Design

The `crew` package consists of `R6` classes. Each object of class `crew` contains an object of class `store` and a list of objects of class `worker`. The `crew`, `store`, and `worker` classes have inheritance hierarchies. Each parent class is an abstract class with a `validate()` method to ensure the concrete instantiable subclasses define all the required methods and fields. The next sections describe these class hierarchies.

# crew

A `crew` represents a group of workers. It contains:

* Its name.
* A `store` object with a data store to send and receive worker data.
* A list of worker objects to manage active workers
* A worker definition to launch new workers.

A crew is in charge of

* Launching new workers.
* Assigning jobs to workers.
* Polling workers.
* Receiving and processing data from workers.
* Terminating workers.

# worker

A `worker` object encapsulates a worker: a local process, cluster process, or cloud process that accepts and runs work that the crew dispatches.

Required fields:

* `name`: name of the worker.
* `crew`: the `crew` object of the crew it belongs to.
* `timeout`: seconds to idle before the worker times out.
* `wait_input`: seconds to wait between polling for input (a new job).
* `assigned`: whether the worker is currently assigned a job.

Required methods:

* `up()`: check whether the worker is running.
* `launch()`: start the worker if it not already running.
* `send()`: send a job to a worker, usually through the crew's data store.
* `receive()`: receive the output of a job from a worker, usually through the crew's data store.
* `done()`: whether the worker is done with its current job and is waiting for the crew to read the output data and free the worker to do another job.
* `shutdown()`: send a special job that gracefully shuts down the worker.
* `validate()`: check for errors in the fields and methods.

Inheritance hierarchy:

```
├── worker
│   ├── worker_callr
│   ├── worker_future
│   │   ├── worker_future_local
```

Instantiable concrete subclasses:

* `"worker_callr"`: worker that runs in a `callr::r_bg()` process.
* `"worker_future_local"`: worker that runs in a `future` and uses a local data store.

Other subclasses will run on cloud services like AWS Batch.

# store

A `store` object manages files on a file system that the workers and the crew both can access. Files may exist locally or on the cloud, depending on the subclass. The directory structure of a data store has a single root folder and sub-directories `input/` and `output/`. The former contains instructions and data for submitted jobs, and the latter contains job output written by the workers. In both cases, there is at most one file per worker, with the base name equal to the worker name. That way, to check if a remote worker completed a job successfully, a worker object can simply check if the `output/` file exists for the job currently running. (Although a separate backend-specific mechanism is needed in order to detect crashed workers.)

Required fields:

* `dir_root`: directory or prefix of the root of the store file system.
* `dir_input`: directory or prefix of the input files where jobs are submitted to.
* `dir_output`: directory or prefix where workers save the output from their jobs.

Required methods:

* `path_input()`: return the job input file path of a worker.
* `path_output()`: return the job output file path of a worker.
* `read_input()`: read a job's input file.
* `read_output()`: read a job's output file.
* `write_input()`: write a job's input file.
* `write_output()`: write a job's output file.
* `exists_input()`: check if a job's input file exists.
* `exists_output()`: check if a job's output file exists.
* `delete_input()`: delete a job's input file.
* `delete_output()`: delete a job's output file.
* `destroy()`: delete all the files of the store.
* `validate()`: check for errors in the fields and methods.

Inheritance hierarchy:

```
├── store
│   ├── store_local
```

The `"store_local"` subclass is the only instantiable sub-class built directly into `crew`. Other packages that depend on `crew` will implement other stores that use AWS/GCP buckets instead of local files.
