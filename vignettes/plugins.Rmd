---
title: "Launcher plugins"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Launcher plugins}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(crew)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

`crew` lets you write custom [launchers](https://wlandau.github.io/crew/reference/crew_class_launcher.html) for different types of workers that connect over the local network. This flexibility can extend `crew` to platforms like [SLURM](https://slurm.schedmd.com/), [AWS Batch](https://aws.amazon.com/batch/), and [Kubernetes](https://kubernetes.io/). This vignette demonstrates how.

## Prerequisites

1. [`R6` classes](https://r6.r-lib.org/articles/Introduction.html).
2. How to launch and terminate a job or process on the computing platform of your plugin.

## How it works

To create your own launcher plugin, write an [`R6`](https://r6.r-lib.org/articles/Introduction.html) subclass of [`crew_class_launcher`](https://wlandau.github.io/crew/reference/crew_class_launcher.html) with a [`launch_worker()`](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html#method-launch-worker-) method analogous the one in the [`callr` launcher](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html). `launch_worker()` must accept a particular set of arguments, generate a call to [`crew_worker()`](https://wlandau.github.io/crew/reference/crew_worker.html), and then submit a new job or process to run that call.

## Tips

* The [source code of the built-in `callr` launcher](https://github.com/wlandau/crew/blob/main/R/crew_launcher_callr.R) is a helpful reference.
* For efficiency, every launch can happen asynchronously. There is no need to wait for the worker to start. When it starts, it will connect back to the `mirai` dispatcher  over the local network and start accepting tasks.
* There is no need to manually terminate the worker. Either it idles out on its own when the workload subsides, depending on user settings, or it exits when the dispatcher exits.

## Example

We create a custom launcher class whose workers are local R processes.

```{r}
custom_launcher_class <- R6::R6Class(
  classname = "custom_launcher_class",
  inherit = crew::crew_class_launcher,
  public = list(
    launch_worker = function(socket, host, port, token, name) {
      call <- self$call(socket, host, port, token, name)
      processx::process$new(command = "R", args = c("-e", call))
    },
    terminate_worker = function(handle) {
      handle$kill()
    }
  )
)
```

## Usage

