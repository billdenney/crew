---
title: "Launcher plugins"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Launcher plugins}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(crew)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

`crew` lets you write custom [launchers](https://wlandau.github.io/crew/reference/crew_class_launcher.html) for different types of workers that connect over the local network. This flexibility can extend `crew` to platforms like [SLURM](https://slurm.schedmd.com/), [AWS Batch](https://aws.amazon.com/batch/), and [Kubernetes](https://kubernetes.io/). This vignette demonstrates how.

## Prerequisites

1. [`R6` classes](https://r6.r-lib.org/articles/Introduction.html).
2. How to launch and terminate a job or process on the computing platform of your plugin.

## How it works

To create your own launcher plugin, write an [`R6`](https://r6.r-lib.org/articles/Introduction.html) subclass of [`crew_class_launcher`](https://wlandau.github.io/crew/reference/crew_class_launcher.html) with a [`launch_worker()`](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html#method-launch-worker-) method analogous the one in the [`callr` launcher](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html). `launch_worker()` must accept the same arguments as the [`callr` `launch_worker()` method](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html#method-launch-worker-), generate a call to [`crew_worker()`](https://wlandau.github.io/crew/reference/crew_worker.html), and then submit a new job or process to run that call.

## Safeguards

We recommend you implement an optional [`terminate_worker()`](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html#method-terminate-worker-) method. Although `mirai` has its own way of terminating workers, it only works if the worker already connected, and it cannot reach workers that fail to connect and hang in a crashed state. An optional [`terminate_worker()`](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html#method-terminate-worker-) method in your `crew` launcher plugin is extra assurance that these workers will exit.

If you implement [`terminate_worker()`](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html#method-terminate-worker-), it must accept a handle that identifies the worker, and this handle must be the return value of the previous call to [`launch_worker()`](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html#method-launch-worker-). A handle can be any kind of R object: a `callr::r_bg()` handle, a process ID, a job name, etc.

## Tips

* The `token` and `name` arguments of the [`launch_worker()` method](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html#method-launch-worker-) can help construct informative job names. `token` is a long text string that uniquely identifies the instance of the new worker, and `name` is the name of the current launcher object.
* For efficiency, every launch can happen asynchronously. There is no need to wait for the worker to start. When it starts, it will connect back to the `mirai` dispatcher  over the local network and start accepting tasks.
* If you implement a [`terminate_worker()`](https://wlandau.github.io/crew/reference/crew_class_launcher_callr.html#method-terminate-worker-) method, each worker termination may also happen asynchonously. In rare cases when you do not trust the platform to terminate the worker on the first request, you can use [`crew_wait()`](https://wlandau.github.io/crew/reference/crew_wait.html) to wait for the job to exit, but this may reduce efficiency.
* The [source code of the built-in `callr` launcher](https://github.com/wlandau/crew/blob/main/R/crew_launcher_callr.R) is a helpful reference.

## Example

The following is a custom custom launcher class whose workers are local R processes.

```{r}
custom_launcher_class <- R6::R6Class(
  classname = "custom_launcher_class",
  inherit = crew::crew_class_launcher,
  public = list(
    launch_worker = function(socket, host, port, token, name) {
      call <- self$call(socket, host, port, token, name)
      processx::process$new(command = "R", args = c("-e", call))
    },
    terminate_worker = function(handle) {
      handle$kill()
    }
  )
)
```

Above `launch_worker()` begins by creating a call to [`crew_worker()`](https://wlandau.github.io/crew/reference/crew_worker.html). Later on, this call will run inside the worker process, connect back to `crew` and `mirai` over the local network, and accept the tasks you push to the controller.

```{r}
call <- self$call(socket, host, port, token, name)
```

The `call` object above a text string with R code. To see what it looks like, you can try the method in a `callr` launcher object.

```{r}
launcher <- crew_launcher_callr()
launcher$call(
  socket = "ws://127.0.0.1:5000",
  host = "127.0.0.1",
  port = "5711",
  token = "my_token",
  name = "my_name"
)
#> [1] "crew::crew_worker(token = \"my_token\", host = \"127.0.0.1\", port = \"5711\", settings = list(url = \"ws://127.0.0.1:5000\", asyncdial = TRUE, maxtasks = Inf, idletime = Inf, walltime = Inf, timerstart = 0L, exitlinger = 100, cleanup = FALSE))"
```

To create an external process that runs a worker, our custom launcher creates a new [`processx`](https://processx.r-lib.org) process to start R and run the [`crew_worker()`](https://wlandau.github.io/crew/reference/crew_worker.html) call.

```{r}
processx::process$new(command = "R", args = c("-e", call))
```

The return value is a handle that `terminate_worker()` will use to terminate the process later on.

```{r}
terminate_worker = function(handle) {
  handle$kill()
}
```

## Helper

It is useful to have a helper function that creates controllers with your custom launcher. It should:

1. Accept all the same arguments as [`crew_controller_callr()`](https://wlandau.github.io/crew/reference/crew_controller_callr.html).
2. Create a router object using [`crew_router()`](https://wlandau.github.io/crew/reference/crew_router.html).
3. Create a launcher object with the [`new()` method](https://wlandau.github.io/crew/reference/crew_class_launcher.html#method-crew_class_launcher-new) of your custom launcher class.
4. Create a new controller using [`crew_controller()`](https://wlandau.github.io/crew/reference/crew_controller.html).
5. Scan the controller for obvious errors using the [`validate()`](https://wlandau.github.io/crew/reference/crew_class_controller.html#method-crew_class_controller-validate) method of the controller.

Feel free to borrow from the [`crew_controller_callr()` source code](https://github.com/wlandau/crew/blob/main/R/crew_controller_callr.R). For packages, you can use the `@inheritParams` [`roxygen2`](https://roxygen2.r-lib.org/) tag to inherit the documentation of all the arguments instead of writing it by hand. You may want to adjust the default arguments based on the specifics of your platform, especially `seconds_launch` if workers take a long time to launch.

```{r}
#' @title Create a controller with the custom launcher.
#' @export
#' @description Create an `R6` object to submit tasks and
#'   launch workers.
#' @inheritParams crew::crew_controller_callr
crew_controller_custom <- function(
  name = NULL,
  workers = 1L,
  host = NULL,
  port = 0L,
  seconds_launch = 30,
  seconds_interval = 0.001,
  seconds_timeout = 5,
  seconds_exit = 0.1,
  seconds_poll_high = 0.001,
  seconds_poll_low = 0.01,
  async_dial = TRUE,
  seconds_idle = Inf,
  seconds_wall = Inf,
  tasks_max = Inf,
  tasks_timers = 0L,
  cleanup = FALSE,
  auto_scale = "demand"
) {
  router <- crew::crew_router(
    name = name,
    workers = workers,
    host = host,
    port = port,
    seconds_interval = seconds_interval,
    seconds_timeout = seconds_timeout,
    seconds_exit = seconds_exit,
    seconds_poll_high = seconds_poll_high,
    seconds_poll_low = seconds_poll_low,
    async_dial = async_dial
  )
  launcher <- custom_launcher_class$new(
    name = name,
    seconds_launch = seconds_launch,
    seconds_interval = seconds_interval,
    seconds_timeout = seconds_timeout,
    seconds_idle = seconds_idle,
    seconds_wall = seconds_wall,
    seconds_exit = seconds_exit,
    tasks_max = tasks_max,
    tasks_timers = tasks_timers,
    async_dial = async_dial,
    cleanup = cleanup
  )
  controller <- crew::crew_controller(
    router = router,
    launcher = launcher,
    auto_scale = auto_scale
  )
  controller$validate()
  controller
}
```

## Usage

