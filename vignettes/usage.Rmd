---
title: "Usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(crew)
library(future)
library(future.callr)
library(purrr)
```

# Setup

First, create a `crew` object.

```{r}
library(crew)
crew <- class_crew$new()
```

Optionally, supply the store and worker classes you plan to use. The store determines where the input and output data live for jobs (local file system, Amazon S3 bucket, Google Cloud bucket, etc.), and worker classes control where and how the workers run (locally in a different R session, Amazon Web Services, Google Cloud Platform, etc.).

```{r}
crew <- class_crew$new(
  store = class_store_local$new(),
  worker_classes = list(
    class_worker_callr,
    class_worker_future
  )
)
```

If you use `class_worker_future`, choose a plan.

```{r}
library(future)
library(future.callr)
plan(callr)
```

# Specify workers.

Create worker objects with the `recruit()` method.

```{r}
crew$recruit(workers = 2) # callr workers
```

Optionally, create worker objects of a specified class and set fields like timeout and tags.

```{r}
names(crew$worker_classes)
crew$recruit(
  workers = 2,
  class = "worker_future",
  tags = c("long_jobs_go_here", "my_future_workers")
)
```

The individual worker interfaces are `R6` objects available in `crew$workers`.

```{r}
lapply(crew$workers, class)
```

# Launch workers and send jobs

No workers are running yet.

```{r}
crew$up()
```

To start any or all workers, either use `launch()` or `send()`. The latter finds a suitable available worker, launches it if necessary, and then sends a job. Poll with `receivable()` and get the output with `receive()`. Tags let you control which kinds of workers get the jobs, and they are are supported and optional in all relevant crew methods.

```{r, warning = FALSE}
job <- function(seconds) {
  Sys.sleep(seconds)
  warning("This is a warning.")
  sprintf("Job ran in %s seconds.", seconds)
}

# The job runs on a worker of class "worker_future" in this case
# because those two workers are tagged with "long_jobs_go_here".
crew$send(fun = job, args = list(seconds = 4), tags = "long_jobs_go_here")

# Do other tasks while the job runs in the background.
do_other_tasks <- function () {
  start <- as.numeric(proc.time()["elapsed"])
  while (!crew$receivable()) {
    Sys.sleep(1)
    print(as.numeric(proc.time()["elapsed"]) - start)
  }
}

do_other_tasks()

# Get the output when ready.
output <- crew$receive()
```

The output contains the result of the job, as well as warnings, errors, etc.

```{r}
str(output)
```

Once launched, workers stay running until they time out or shut down.

```{r}
is_up <- vapply(crew$workers, \(.x) .x$up(), FUN.VALUE = logical(1))
is_up
```

Sure enough, the running worker has the tags of the previous job.

```{r}
name <- names(is_up[is_up])
crew$workers[[name]]$tags
```

# Send more jobs

`crew` tries to send jobs to workers that are already running. If all running workers are busy, new ones will launch automatically. Use `sendable()` to check if any workers can accept new work.

```{r, warning = FALSE}
crew$send(fun = job, args = list(seconds = 8), tags = "long_jobs_go_here")
crew$send(fun = job, args = list(seconds = 4)) # May run on any available worker.

do_other_tasks()

output_first <- crew$receive()

do_other_tasks()

output_second <- crew$receive()

str(output_first)

str(output_second)
```

# Shut down and dismiss workers

To shut down one or more workers, use `shutdown()`. By default, only idle workers are shut down.

```{r}
crew$shutdown()
while (crew$up()) {
  Sys.sleep(0.1)
}
```

To delete one or more worker objects from the crew, use `dismiss()`.

```{r}
crew$dismiss(tags = "long_jobs_go_here")
length(crew$workers) # Should be 2.
```

# Crashes and restarts

If eventually a worker gets stuck (not sendable, not receivable, not running) then the `stuck()` method of the worker will return `TRUE` and the `restart()` method will restart it. Use the `restart()` method of the crew object to restart one or more stuck workers.
