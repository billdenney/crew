---
title: "Usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
set.seed(0)
library(crew)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  paged.print = FALSE
)
```

## Local task queues

`crew`'s multi-session task queue is much like <https://www.tidyverse.org/blog/2019/09/callr-task-q/>. To start a queue, call `crew_queue_session$new()` and supply the number of workers, or background processes, that are capable of accepting tasks.

```{r}
queue <- crew_queue_session$new(workers = 2)
```

Immediately, two background processes start. We can inspect them with the `get_workers()` method. The `handle` column is a list column with [`callr::r_session`](https://callr.r-lib.org/reference/r_session.html) handles.

```{r}
queue$get_workers()
```

No tasks are waiting to be assigned to workers,

```{r}
queue$get_tasks()
```

and no results are available from completed tasks.

```{r}
queue$get_results()
```

To assign a task, we create a function in R and a named list of arguments. We supply that information to the `push()` method of the queue.

```{r}
fun <- function(seconds) {
  Sys.sleep(seconds)
  return(paste("ran for", seconds, "seconds and completed successfully"))
}
  
queue$push(fun = fun, args = list(seconds = 1))
```

Control returns to the main R session immediately, and the the task runs in the background. Call `pop()` to check on the results and return the latest one if available.

```{r}
while (is.null(result <- queue$pop())) {
  Sys.sleep(0.25)
  message("still waiting")
}

str(result)
```

```{r}
result$result$result
```

Internally, `push()` and `pop()` call the `update()` method,^[Actually, they all call the private `update_all()` method, and the public `update()` method does nothing else.] which is like the `schedule()` method in the [100-line task queue](https://www.tidyverse.org/blog/2019/09/callr-task-q/). `update()` shuffles waiting tasks to available works, checks if workers are done (or crashed), and collects output so it is available for `get_results()` or `pop()`. It is recommended to invoke the task queue at regular intervals to assign new tasks and collect results. Here is a sketch of such an event loop. The [`targets`](https://docs.ropensci.org/targets/) package and heavy-duty [Shiny](https://shiny.rstudio.com) apps have event loops like this one.

```{r}
fun <- function(seconds) {
  Sys.sleep(seconds)
  seconds
}

tasks <- runif(n = 25, min = 0.1, max = 1)
results <- numeric(0)

for (task in tasks) {
  queue$push(fun = fun, args = list(seconds = task))
  result <- queue$pop()
  if (!is.null(result)) {
    results <- c(results, result$result$result)
  }
}

while (length(results) < length(tasks)) {
  result <- queue$pop()
  if (!is.null(result)) {
    results <- c(results, result$result$result)
  }
}
```

Because the tasks run asynchronously, they may finish in a different order than you submitted them.

```{r}
round(tasks, 3)
```

```{r}
round(results, 3)
```

When you are done with the queue, call the `shutdown()` method to terminate the workers.

```{r}
queue$shutdown()
```

## Other task queues

The `crew_queue_future` task queue uses transient [`future`](https://future.futureverse.org)'s as workers. The queue has a default `future::plan()`, and you can set an individual plan for each task you push. The plan can either be the sequential plan or a plan from [`future.batchtools`](https://future.batchtools.futureverse.org)^[other plans are not supported because they cannot be sent to the [`callr::r_session`](https://callr.r-lib.org/reference/r_session.html) workers in the subqueue). [`future.batchtools`](https://future.batchtools.futureverse.org) workers have high overhead for submitting, polling, and collecting tasks, so `crew_queue_future` supports a subqueue, a local multi-process queue inside the larger queue to asynchronously manage the [`future`](https://future.futureverse.org)'s internally. 

A `crew_queue_future` queue is created just like a `crew_queue_session` queue, except there are a couple more arguments.

```{r, eval = FALSE}
queue <- crew_queue_future(
  workers = 16, # Max future workers running at a time,
  store = crew_store_local$new(root = "my_store"),
  plan = future.batchtools::batchtools_slurm(template = "my_template.tmpl"),
  subqueue = crew_queue_session$new(workers = 4)
)
```

The meanings of most of these arguments are covered in the paragraph above. The `store` argument is a local data store for sending and receiving work that the [`future`](https://future.futureverse.org)'s do. For [`future.batchtools`](https://future.batchtools.futureverse.org) futures, the `root` of the data store should point to a file system that all the workers can access, not just the main R process on the login node.
