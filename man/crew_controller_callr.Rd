% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crew_controller_callr.R
\name{crew_controller_callr}
\alias{crew_controller_callr}
\title{Create a controller with a callr launcher.}
\usage{
crew_controller_callr(
  name = NULL,
  workers = 1L,
  host = NULL,
  ports = NULL,
  router_timeout = 5,
  router_wait = 0.1,
  idle_time = Inf,
  wall_time = Inf,
  poll_high = 5,
  poll_low = 50,
  launch_timeout = 5,
  launch_wait = 0.1,
  max_tasks = Inf,
  async_dial = TRUE,
  auto_scale = "demand"
)
}
\arguments{
\item{name}{Name of the \code{mirai} router.
Defaults to a string from \code{ids::proquint()}.}

\item{workers}{Integer, maximum number of parallel workers to run.
\code{crew} will reserve one ephemeral port for each worker. See the
Ports section for an important cautionary note.}

\item{host}{IP address of the client process that the workers can dial
into inside the local network.
If a character string, the router uses the specified IP address.
If \code{NULL}, the IP address defaults to \code{getip::getip(type = "local")}.}

\item{ports}{Optional integer vector of TCP port numbers.
Supersedes \code{workers} if supplied. Except for 0,
which defers to NNG to automatically assign a port, each unique port
value corresponds to a local port where a worker will dial in
to accept tasks.}

\item{router_timeout}{Number of seconds to time out waiting for the \code{mirai}
router to (dis)connect.}

\item{router_wait}{Number of seconds to wait between iterations checking
if the \code{mirai} router is (dis)connected.}

\item{idle_time}{Maximum number of seconds that a worker can idle
since the completion of the last task. If exceeded, the worker exits.}

\item{wall_time}{Soft wall time in seconds. See the \code{wall_time}
argument of \code{mirai::server()}.}

\item{poll_high}{High polling interval in seconds for the \code{mirai}
active queue.}

\item{poll_low}{Low polling interval in seconds for the \code{mirai}
active queue.}

\item{launch_timeout}{Number of seconds to time out
waiting for a new group of workers to launch.}

\item{launch_wait}{Number of seconds to wait between checks
that newly launched workers are ready to receive tasks.}

\item{max_tasks}{Maximum number of tasks that a worker will do before
exiting.}

\item{async_dial}{Logical, whether the \code{mirai} workers should dial in
asynchronously. See the \code{asyncdial} argument of \code{mirai::server()}.}

\item{auto_scale}{Character of length 1, name of the method for
automatically scaling workers to meet demand. \code{NULL} to default to
\code{"demand"}. Possible values include the following:
\itemize{
\item \code{"demand"}: just after pushing a new task in \code{push()}, launch
\code{min(n, max(0, t - w))} workers, where \code{n} is the maximum number of
workers, \code{t} is the number of queued tasks, and \code{w} is the current
number of workers already running. In other words, scale up the
number of workers to meet the current demand.
\item \code{"single"}: just after pushing a new task in \code{push()}, launch
a single worker if demand \code{min(n, max(0, t - w))} is greater than 0.
\item \code{"none"}: do not auto-scale at all.
}}
}
\description{
Create an \code{R6} object to submit tasks and
launch \code{callr} workers.
}
\examples{
if (identical(Sys.getenv("CREW_EXAMPLES"), "true")) {
controller <- crew_controller_callr()
controller$connect()
controller$push(name = "task", command = sqrt(4))
controller$wait()
controller$pop()
controller$terminate()
}
}
\seealso{
Other controllers: 
\code{\link{crew_class_controller}},
\code{\link{crew_class_multi_controller}},
\code{\link{crew_controller}()},
\code{\link{crew_multi_controller}()}
}
\concept{controllers}
